MyData <- read.csv("../data/trees.csv")
ls(pattern = "My*")
class(MyData)
head(MyData)
str(MyData)
MyData <- read.csv(../data/trees.csv")
header = F)
q
MyData <- read.csv("../data/trees.csv",header = F)
head(MyData)
MyData <- read.table("../data/trees.csv", sep = ',', header = TRUE)
head(MyData)
write.csv(MyData, "../results/MyData.csv")
write.csv(MyData,"../results/MyData.csv")
dir("../results/")
write.table(MyData[1,],file = "../results/MyData.csv",append=TRUE)
write.csv(MyData,"../results/MyData.csv",row.names = TRUE)
write.table(MyData, "../results/MyData.csv", col.names=FALSE)
source("basic_io.R")
R CMD BATCH MyCode.R MyResults.Rout
a <- TRUE
if (a == TRUE){
    print ("A is TRUE")
} else {
    print ("a is FALSE")
}
z <- runif(1)
if (z <= 0.5){print ("Less than a half")}
z <- runif(1)
if (z<=0.5) {print ("Less than a half")}
for (i in 1:10) {
    j <- i * i
    print(paste(i, " squared is", j ))
}
seq(10)
1:10
for (species in c('Heliodoxa rubinoides', 'Boissonneaua jardini', 'Sula nebouxii')){
    print(paste('The species is', species))
}
i <- 0
while (i < 10){
    i <- i + 1
    print(i^2)
}
source("control_flow.R")
source("boilerplate.R")
source("boilerplate.R")
ls(pattern = "MyFun*)
ls(pattern = "MyFun*")
class(MyFunction)
is.even <- function( n = 2 ) {
    if (n %% 2 == 0) {
        return(paste(n, 'is even!'))
    } else {
        return(paste(n,'is odd!'))
    }
}
is.even(6)
source("R_conditionals.R")
source("R_conditionals.R")
is.prime(3)
is.power2(4)
is.even(6)
source("TreeHeight.R")
a <- 1.0
class(a)
float a
source("Vectorize1.R")
source("Vectorize1.R")
source("Vectorize1.R")
NoPreallocFunc <- function(x) {
    a <- vector()
    for (i in 1:x) {
        a <- c(a, i)
        print(a)
        print(object.size(a))
    }
}
system.time(NoPrealliocFunc(10))
NoPreallocFun <- function(x) {
    a <- vector() # empty vector
    for (i in 1:x) {
        a <- c(a, i) # concatenate
        print(a)
        print(object.size(a))
    }
}
system.time(NoPreallocFun(10))
NoPreallocFun <- function(x) {
    a <- vector()
    for (i in 1:x) {
        a <- c(a, i)
        print(a)
        print(object.size(a))
    }
}
system.time(NoPreallocFun(10))
?apply
## Build a random matrix
M <- matrix(rnorm(100),10,10)
## Take the mean of each row
RowMeans <- apply(M, 1, mean)
print (RowMeans)
# Now the variance
RowVars <- apply(M, 1, var)
print (RowVars)
a <- 1.0
class(a)
float a
M <- matrix(rnorm(100),10,10)
RowMeans <- apply(M, 1, mean)
print (RowMeans)
ColMeans <- apply(M, 2, mean)
print (ColMeans)
ls
cd ..
ls
source apply2.R
run apply2.R
import my_module
run control_flow.py
ls
MyData <- as.matrix(read.csv("../data/PoundHillData.csv",header = FALSE))
class(MyData)
MyMetaData <- read.csv("../data/PoundHillMetaData.csv",header = TRUE,  sep=";")
class(MyMetaData)
head(MyData)
view(MyData)
source("Vectoriza2.R")
source("Vectorize2.R")
source("Vectorize2.R")
source("Vectorize2.R")
source("Vectorize2.R")
is.even <- function(n = 2) {
  if (n %% 2 == 0) {
    return(paste(n,'is even!'))
  } else {
  return(paste(n,'is odd!'))
  }
}
is.even(6)
is.even1 <- function(n){
if (n%%2 == 0){
return(paste(n, 'is even'))
} else {
return(paste(n,'is odd'))
}
}
is.even1(6)
is.even <- function(n = 2) {
  if (n %% 2 == 0) {
    return(paste(n,'is even!'))
  } else {
  return(paste(n,'is odd!'))
  }
}
is.even
is.even()
source("try.R")
rm(list=ls())
load("../data/KeyWestAnnualMeanTemperature.RData")
ls()
wget content/data/KeyWestAnnualMeanTemperature.RData
q()
set.seed(1)
randcorr <- c()
for (i in 1:100){
randcorr[i] <- cor(ats$Year, sample(ats$Temp))
}
load("../data/KeyWestAnnualMeanTemperature.RData")
corrcoeff <- cor(ats$Year, ats$Temp)
set.seed(1)
randcorr <- matrix(0,nrow = 100, ncol = 100)
for (i in 1:100){
randcorr[i] <- cor(ats$Year, sample(ats$Temp))
}
a <- 0
for (j in randcorr){
if (j > corrcoeff){
a <- a + 1
}
}
a
?rep
set.seed(1)
randcorr <- matrix(0,nrow = 100, ncol = 100)
for (i in 1:100) {
    randcorr[,i] <- sample(ats$Temp, replace = FALSE)
}
corr <- rep(0,100)
for (i in 1:100){
    corr[i] <- cor(randcorr[,i], ats$Year)
}
corr
# calculating correlation coefficient for original data
ogdata <- cor(y=ats$Temp, x=ats$Year, method = "pearson")
# for reproducability of results
set.seed(1)
# the number of observations to sample
n <- length(ats$Year)
# the number of permutation samples to take
P <- 100
# the variable we will resamples from 
variable <- ats$Temp
# initialise a matrix to store the permutation data
PermSamples <- matrix(0, nrow = n, ncol = P) # each column is a permutation sample of data
for (i in 1:P) {
  PermSamples[,i] <- sample(variable, size=n, replace=FALSE)
}
PermSamples[, 1:5]
#initialise vectors to store all of the Test stats:
Perm.test.stat1 <- rep(0, P)
#calculate the test-stats
for (i in 1:P){
  Perm.test.stat1[i] <- cor(PermSamples[,i], ats$Year, method = "pearson")
}
# calculate the permutation p-value and store
mean(Perm.test.stat1 >= ogdata)
no_times_larger <- sum(Perm.test.stat1 >= ogdata)
p_vaue <- no_times_larger/P
p_value
ogdata <- cor(y=ats$Temp, x=ats$Year, method = "pearson")
n <- length(ats$Year)
P <- 100
set.seed(1)
variable <- ats$Temp
PermSamples <- matrix(0, nrow = n, ncol = P) # each column is a permutation sample of data
for (i in 1:P) {
  PermSamples[,i] <- sample(variable, size=n, replace=FALSE)
}
PermSamples[, 1:5]
Perm.test.stat1 <- rep(0, P)
for (i in 1:P){
  Perm.test.stat1[i] <- cor(PermSamples[,i], ats$Year, method = "pearson")
}
mean(Perm.test.stat1 >= ogdata)
no_times_larger <- sum(Perm.test.stat1 >= ogdata)
no_times_larger
p_vaue <- no_times_larger/P
p_value
class(ats)
head(ats)
view(ats)
View(ats)
install.packages("XQuartz")
names(ats)\
names(ats)
randcorr <- c()
for (i in 1:100) {
    randcorr[i] <- cor(ats$Year, sample(ats$Temp))
}
randcorr
source("/Users/xuan/Documents/IC/CMEECourseWork/Week3/code/Florida.R", encoding = "UTF-8")
p_value
plot(ats)
# Author: An an.nguyen21@imperial.ac.uk
# Script: Florida.R
# Desc: Your goal is to write an R script that will help answer the question: 
#       Is Florida getting warmer? To answer the question, you need to calculate 
#       the correlation coefficients between temperature and time. 
#       However, you canâ€™t use the standard p-value calculated for a correlation coefficient, 
#       because measurements of climatic variables in successive time-points in a time series 
#       (successive seconds, minutes, hours, months, years, etc.) are not independent. 
#       Therefore you will use a permutation analysis instead, by generating a distribution of 
#       random correlation coefficients and compare your observed coefficient with this random distribution.
# Arguments: 1 (data file)
# Output: approximate, asymptotic p-value
# Date: Oct 2021
#clear workspace
rm(list=ls())
#load data
load("../data/KeyWestAnnualMeanTemperature.RData")
#correlation coefficient between years and temperature
ce <- cor(ats$Year, ats$Temp)
#calculate possible combination of years and temperature
#200 samples, 19900 possible combinations
numdata <- nrow(ats) * ncol(ats)
sampletime <- numdata * (numdata -1)/2
#shuffle temperature, each time randomly 
#re-assigning temperatures to year
shuffle_cor <- function(x) {
    x[,2] <- sample(x[,2])
    return (cor(x[,1], x[,2]))
}
#repeat the shuffling 19900 times
calfraction <- sapply(1:sampletime, function(i) shuffle_cor(ats))
# histogram to compare coefficient correlations
pdf("../results/Floridaplot.pdf")
hist(calfraction, 
    xlim = c(-0.6, 0.6),
    xlab = "Correlation coefficients of random sample",
    main = NULL)
abline(v = ce, col="blue", lwd=3, lty=2)
text(0.27, 3300, "Original correlation coefficient 
     \n between years and temperature: 0.533", cex = 0.65, col="blue")
dev.off()
#calculate approximate, asymptotic p-value (what fraction of 
#the random correlation coefficients were greater than the observed one 
p <- sum(calfraction >= ce)/length(calfraction)
p
p
cor(ats$Year, ats$Temp)
q()
